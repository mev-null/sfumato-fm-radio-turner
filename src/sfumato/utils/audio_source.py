# generated by Gemini 3 Pro
import numpy as np
import soundfile as sf
from scipy import signal


class AudioSource:
    """
    シミュレーション用のオーディオデータを生成・読み込みするクラス
    """

    def __init__(self, sample_rate: float = 48000.0):
        self.fs = sample_rate

    def sine_tone(
        self, frequency: float, duration: float, amplitude: float = 0.8
    ) -> np.ndarray:
        """
        指定した周波数の正弦波（サイン波）を生成します。

        Args:
            frequency: 周波数 (Hz) 例: 440.0 (ラの音)
            duration: 長さ (秒)
            amplitude: 振幅 (0.0 ~ 1.0)

        Returns:
            np.ndarray: 音声データ配列 (-1.0 ~ 1.0)
        """
        t = np.arange(int(self.fs * duration)) / self.fs
        # sin(2πft)
        wave = amplitude * np.sin(2 * np.pi * frequency * t)
        return wave.astype(np.float32)

    def load_wav(self, filepath: str, duration: float = None) -> np.ndarray:
        """
        WAVファイルを読み込み、モノラル化・リサンプリング・正規化を行います。

        Args:
            filepath: ファイルパス
            duration: 読み込む長さ（秒）。Noneなら全部。

        Returns:
            np.ndarray: 音声データ配列
        """
        # soundfileで読み込み
        data, original_fs = sf.read(filepath, always_2d=True)

        # 1. ステレオ→モノラル変換 (平均をとる)
        # dataは (samples, channels) の形
        if data.shape[1] > 1:
            data = np.mean(data, axis=1)
        else:
            data = data.flatten()

        # 2. リサンプリング (元のレートが違う場合)
        if original_fs != self.fs:
            number_of_samples = int(len(data) * self.fs / original_fs)
            data = signal.resample(data, number_of_samples)

        # 3. 指定した長さで切り出し
        if duration is not None:
            max_samples = int(self.fs * duration)
            if len(data) > max_samples:
                data = data[:max_samples]

        # 4. 正規化 (最大値を1.0にする)
        max_val = np.max(np.abs(data))
        if max_val > 0:
            data = data / max_val * 0.9  # 0.9掛けでクリップ防止

        return data.astype(np.float32)
