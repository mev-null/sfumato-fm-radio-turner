# generated by Gemini 3 Pro
import os
import soundfile as sf
import numpy as np
import math
from scipy import signal


def load_and_preprocess_wav(
    filename: str, target_fs: int, mono: bool = True
) -> np.ndarray:
    """
    WAVファイルを読み込み、リサンプリング・正規化を行う。

    Args:
        filename: ファイルパス
        target_fs: 目標サンプリング周波数
        mono: Trueなら強制的にモノラル化、Falseなら元のチャンネル数を維持

    Returns:
        np.ndarray: 音声データ (N,) または (N, 2)
    """
    if not os.path.exists(filename):
        raise FileNotFoundError(f"File not found: {filename}")

    # 1. 読み込み (always_2d=False なので、モノラルは(N,), ステレオは(N, 2))
    data, fs = sf.read(filename)

    # 2. チャンネル処理
    if mono:
        # ステレオ入力かつモノラル出力希望の場合 -> 平均を取ってダウンミックス
        if data.ndim > 1:
            data = data.mean(axis=1)
    else:
        # ステレオ出力希望なのにモノラル入力だった場合 -> 複製して2chにする (オプション)
        if data.ndim == 1:
            data = np.column_stack([data, data])

    # 3. リサンプリング
    # scipy.signal.resample_poly はデフォルトで axis=0 (行方向) を処理するため、
    # (N, 2) のステレオデータもそのまま渡せば左右独立してリサンプリングされます。
    if fs != target_fs:
        gcd = math.gcd(target_fs, fs)
        up = target_fs // gcd
        down = fs // gcd
        data = signal.resample_poly(data, up, down)

    # 4. 型変換と正規化
    data = data.astype(np.float32)

    # ステレオの場合、全体の最大値で割ることで左右のバランス（定位）を維持します
    max_val = np.abs(data).max()
    if max_val > 1.0:
        data = data / max_val

    return data
