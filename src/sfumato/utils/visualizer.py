# generated by Gemini 3 Pro
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq, fftshift
from scipy.signal.windows import hann


def plot_signal_analysis(
    signal: np.ndarray,
    fs: float,
    title: str = "Signal Analysis",
    zoom_usec: float = 100.0,
    carrier_freq: float = None,
    figsize: tuple = (12, 8),
):
    """
    時間領域の波形と、周波数領域のスペクトルを同時にプロットします。

    Args:
        signal (np.ndarray): 入力信号データ（実数または複素数）
        fs (float): サンプリング周波数 [Hz]
        title (str): グラフのタイトル
        zoom_usec (float): 時間軸の拡大範囲 [マイクロ秒] (デフォルト: 100μs)
        carrier_freq (float, optional): 搬送波周波数のマーカー位置 [Hz]
        figsize (tuple): 図のサイズ
    """

    # --- データの準備 ---
    N = len(signal)
    t = np.arange(N) / fs

    # 複素信号(IQ)か実信号かで処理を分ける
    is_complex = np.iscomplexobj(signal)

    # --- 1. 時間軸プロット (Time Domain) ---
    fig, axes = plt.subplots(2, 1, figsize=figsize, constrained_layout=True)

    ax_time = axes[0]

    # ズーム範囲のサンプル数を計算
    zoom_samples = int(zoom_usec * 1e-6 * fs)
    if zoom_samples > N:
        zoom_samples = N

    # 時間軸をマイクロ秒単位に変換してプロット
    t_zoom = t[:zoom_samples] * 1e6
    sig_zoom = signal[:zoom_samples]

    if is_complex:
        ax_time.plot(
            t_zoom, sig_zoom.real, label="I (Real)", color="#1f77b4", alpha=0.8
        )
        ax_time.plot(
            t_zoom, sig_zoom.imag, label="Q (Imag)", color="#ff7f0e", alpha=0.8
        )
        ax_time.set_ylabel("Amplitude (I/Q)")
    else:
        ax_time.plot(t_zoom, sig_zoom, color="#2ca02c")
        ax_time.set_ylabel("Amplitude")

    ax_time.set_title(f"{title} - Time Domain (First {zoom_usec} μs)")
    ax_time.set_xlabel("Time [μs]")
    ax_time.grid(True, linestyle="--", alpha=0.6)
    if is_complex:
        ax_time.legend(loc="upper right")

    # --- 2. 周波数軸プロット (Frequency Domain) ---
    ax_freq = axes[1]

    # FFTのサイズ（データが多すぎる場合は制限する）
    n_fft = min(65536, N)  # 2の乗数が高速

    # 窓関数を適用してスペクトル漏れを防ぐ
    window = hann(n_fft)
    sig_fft_in = signal[:n_fft] * window

    # FFT計算
    yf = fft(sig_fft_in)
    yf = fftshift(yf)  # 0Hzを中心に移動
    xf = fftfreq(n_fft, 1 / fs)
    xf = fftshift(xf)

    # パワースペクトル密度 (dB) に変換
    # 1e-12 は log(0) を防ぐための微小値
    mag_db = 20 * np.log10(np.abs(yf) / n_fft + 1e-12)

    # プロット
    ax_freq.plot(xf / 1e3, mag_db, color="#9467bd", linewidth=1.2)

    # 搬送波周波数にマーカーを表示
    if carrier_freq is not None:
        ax_freq.axvline(
            x=carrier_freq / 1e3,
            color="r",
            linestyle=":",
            label=f"Carrier: {carrier_freq / 1e3:.1f} kHz",
        )
        # 負の周波数側も表示（実信号の場合）
        if not is_complex:
            ax_freq.axvline(x=-carrier_freq / 1e3, color="r", linestyle=":", alpha=0.5)
        ax_freq.legend()

    ax_freq.set_title("Frequency Domain (Spectrum)")
    ax_freq.set_xlabel("Frequency [kHz]")
    ax_freq.set_ylabel("Magnitude [dB]")
    ax_freq.grid(True, linestyle="--", alpha=0.6)
    ax_freq.set_xlim([xf.min() / 1e3, xf.max() / 1e3])  # 全帯域を表示

    plt.show()
